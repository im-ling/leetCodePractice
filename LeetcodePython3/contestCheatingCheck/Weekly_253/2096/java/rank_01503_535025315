class Solution {
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        HashMap<Integer, Integer> mp = new HashMap<>();
        int at = 0;
        ArrayList<Integer> cpy = new ArrayList<>();
        for(int i = 0; i < obstacles.length; i++){
            cpy.add(obstacles[i]);
        }
        Collections.sort(cpy);
        for(int i = 0; i < obstacles.length; i++){
            if(!mp.containsKey(cpy.get(i))){
                mp.put(cpy.get(i), at);
                at++;
            }
        }
        int dp[] = new int[obstacles.length];
        int ans[] = new int[obstacles.length];
        SegmentTree st = new SegmentTree(0, dp.length - 1, dp);
        for(int i = 0; i < obstacles.length; i++){
            ans[i] = 1 + st.maxRangeQuery(0, mp.get(obstacles[i]));
            st.pointUpdate(mp.get(obstacles[i]), ans[i]);
        }
        return ans;
    }
}

class SegmentTree {
  private SegmentTree lTree, rTree;
  private int lIdx, rIdx;
  private int max, sum;
  private int lazy;

  public SegmentTree(int l, int r, int arr[]){
    lIdx = l;
    rIdx = r;
    lazy = 0;
    if(l == r){
      max = arr[l];
      sum = arr[l];
    } else {
      lTree = new SegmentTree(l, (r + l)/2, arr);
      rTree = new SegmentTree((r + l)/2 + 1, r, arr);
      max = Math.max(lTree.getMax(), rTree.getMax());
      sum = lTree.getSum() + rTree.getSum();
    }
  }

  public int getMax(){
    return max;
  }

  public int getSum(){
    return sum;
  }

  public int maxRangeQuery(int l, int r){
    if(lazy != 0){
      max += lazy;
      if(lTree != null){
        lTree.lazyPush(lazy);
      }
      if(rTree != null){
        rTree.lazyPush(lazy);
      }
      lazy = 0;
    }
    if(l > rIdx || r < lIdx){
      return Integer.MIN_VALUE;
    }
    if(l <= lIdx && r >= rIdx){
      return max;
    }
    return Math.max(lTree.maxRangeQuery(l, r), rTree.maxRangeQuery(l, r));
  }

  public int sumRangeQuery(int l, int r){
    if(lazy != 0){
      sum += (lazy * (rIdx - lIdx + 1));
      if(lTree != null){
        lTree.lazyPush(lazy);
      }
      if(rTree != null){
        rTree.lazyPush(lazy);
      }
      lazy = 0;
    }
    if(l > rIdx || r < lIdx){
      return 0;
    }
    if(l <= lIdx && r >= rIdx){
      return sum;
    }
    return lTree.sumRangeQuery(l, r) + rTree.sumRangeQuery(l, r);
  }

  public void lazyPush(int val){
    lazy += val;
  }

  public void rangeUpdate(int l, int r, int inc){
    if(l > rIdx || r < lIdx){
      return;
    }
    if(l <= lIdx && r >= rIdx){
      sum += (inc * (rIdx - lIdx + 1));
      max += inc;
      if(lTree != null){
        lTree.lazyPush(inc);
      }
      if(rTree != null){
        rTree.lazyPush(inc);
      }
    } else {
      lTree.rangeUpdate(l, r, inc);
      rTree.rangeUpdate(l, r, inc);
      max = Math.max(lTree.getMax(), rTree.getMax());
      sum = lTree.getSum() + rTree.getSum();
    }
  }

  public void pointUpdate(int pos, int elem){
    if(lIdx != rIdx){
      if(pos <= (rIdx + lIdx)/2){
        lTree.pointUpdate(pos, elem);
      } else {
        rTree.pointUpdate(pos, elem);
      }
      max = Math.max(lTree.getMax(), rTree.getMax());
      sum = lTree.getSum() + rTree.getSum();
    } else {
      max = elem;
      sum = elem;
    }
  }
}