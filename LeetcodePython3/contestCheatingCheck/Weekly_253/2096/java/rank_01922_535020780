class Solution {
    int[] dp;
    boolean[] flag;
    int[] nums;
    int length;
    int f(int n) {
        if (n == 0)
            return 1;
        if (flag[n])
            return dp[n];
        int ans = 1;
        for (int i = 1; i <= n; i++) {
            if (nums[n - i] < nums[n])
                ans = Math.max(ans, f(n - i) + 1);
        }
        dp[n] = ans;
        flag[n] = true;
        return dp[n];
    }
    int len = 0;
    public int lengthOfLIS(int p) {
        int index = find(0, len, nums[p], dp);
        if (index == len)
            len++;
        dp[index] = nums[p];
        return index + 1;
    }
    
    int find(int p, int q, int t, int[] dp) {
        if (p >= q)
            return p;
        while (p < q) {
            int mid = p + (q - p) / 2;
            if (dp[mid] <= t)
                p = mid + 1;
            else 
                q = mid;
        }
        return p;
    }
    public int[] longestObstacleCourseAtEachPosition(int[] nums) {
        this.nums = nums;
        length = nums.length;
        int[] res = new int[length];
        dp = new int[length];
        for (int i = 0; i < res.length; i++) {
            res[i] = lengthOfLIS(i);
        }
        return res;
    }
}