class Solution {
    public int[] longestObstacleCourseAtEachPositionNaive(int[] obstacles) {
        if (obstacles == null || obstacles.length == 0) {
            return new int[0];
        }

        int n = obstacles.length;

        // int[] prefixMaxes = new int[n];
        int[] dp = new int[n];

        // prefixMaxes[0] = obstacles[0];
        dp[0] = 1;

        for (int i = 1; i < n; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (obstacles[j] > obstacles[i]) continue;
                if (dp[j] + 1 > dp[i]) {
                    dp[i] = dp[j] + 1;
                }
            }
        }

        return dp;
    }


    public int[] longestObstacleCourseAtEachPositionIncorrect(int[] obstacles) {
        if (obstacles == null || obstacles.length == 0) {
            return new int[0];
        }

        int n = obstacles.length;

        int[] dp = new int[n];
        int[] maxSmallerLatestIndex = new int[n];
        TreeMap<Integer, Integer> map = new TreeMap<>();
        for (int i = 0; i < n; i++) {
            Map.Entry<Integer, Integer> leftEntry = map.floorEntry(obstacles[i]);
            maxSmallerLatestIndex[i] = leftEntry == null ? -1 : leftEntry.getValue();
            map.put(obstacles[i], i);
        }

        // prefixMaxes[0] = obstacles[0];
        dp[0] = 1;

        for (int i = 1; i < n; i++) {
            dp[i] = 1;
            int j = maxSmallerLatestIndex[i];
            if (j > -1) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        return dp;
    }


    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        if (obstacles == null || obstacles.length == 0) {
            return new int[0];
        }

        int n = obstacles.length;

        int[] dp = new int[n];
        int[] prefixIndexTable = new int[n];
        int[] prefixValueTable = new int[n];
        prefixIndexTable[0] = 0;
        prefixValueTable[0] = obstacles[0];

        dp[0] = 1;
        int len = 1;
        for (int i = 1; i < n; i++) {

            int afterAppend = search(prefixValueTable, obstacles[i] + 0.1, 0, len);

            if (afterAppend == 0) {
                dp[i] = 1;
            } else {
                int prevIndex = prefixIndexTable[afterAppend - 1];
                dp[i] = dp[prevIndex] + 1;
            }

            // replace
            prefixIndexTable[afterAppend] = i;
            prefixValueTable[afterAppend] = obstacles[i];

            if (afterAppend == len) {
                len++;
            }
        }

        return dp;
    }


    // search first i where a[i] >= target
    private int search(int[] a, double target, int l, int r) {
        while (l < r) {
            int m = l + (r - l) / 2;
            if (a[m] >= target) {
                r = m;
            } else {
                l = m + 1;
            }
        }

        return r;
    }


    public static void main(String[] args) {
        Solution s = new Solution();

        //
        //
        //Example 1:
        //
        //Input: obstacles = [1,2,3,2]
        //Output: [1,2,3,3]
        //Explanation: The longest valid obstacle course at each position is:
        //- i = 0: [1], [1] has length 1.
        //- i = 1: [1,2], [1,2] has length 2.
        //- i = 2: [1,2,3], [1,2,3] has length 3.
        //- i = 3: [1,2,3,2], [1,2,2] has length 3.
        System.out.println(Arrays.toString(s.longestObstacleCourseAtEachPosition(new int[]{1, 2, 3, 2})));

        //Example 2:
        //
        //Input: obstacles = [2,2,1]
        //Output: [1,2,1]
        //Explanation: The longest valid obstacle course at each position is:
        //- i = 0: [2], [2] has length 1.
        //- i = 1: [2,2], [2,2] has length 2.
        //- i = 2: [2,2,1], [1] has length 1.
        System.out.println(Arrays.toString(s.longestObstacleCourseAtEachPosition(new int[]{2, 2, 1})));


        //Example 3:
        //
        //Input: obstacles = [3,1,5,6,4,2]
        //Output: [1,1,2,3,2,2]
        //Explanation: The longest valid obstacle course at each position is:
        //- i = 0: [3], [3] has length 1.
        //- i = 1: [3,1], [1] has length 1.
        //- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.
        //- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.
        //- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.
        //- i = 5: [3,1,5,6,4,2], [1,2] has length 2.
        System.out.println(Arrays.toString(s.longestObstacleCourseAtEachPosition(new int[]{3, 1, 5, 6, 4, 2})));


        //Input:
        //[5,1,5,5,1,3,4,5,1,4]
        //Output:
        //[1,1,2,3,2,3,4,4,3,5]
        //Expected:
        //[1,1,2,3,2,3,4,5,3,5]
        System.out.println(Arrays.toString(s.longestObstacleCourseAtEachPosition(new int[]{5, 1, 5, 5, 1, 3, 4, 5, 1, 4})));
        System.out.println(Arrays.toString(s.longestObstacleCourseAtEachPositionNaive(new int[]{5, 1, 5, 5, 1, 3, 4, 5, 1, 4})));

    }
}