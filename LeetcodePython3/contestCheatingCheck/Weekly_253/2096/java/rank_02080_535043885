class Solution {
    int map[];
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        LIS(obstacles);
        
        return map;
    }
    
    /*LIS in nlog(n) */

    int LIS(int[] arr){
      int size = arr.length;
      
      /*
         Here, endElement array contains the end element of increasing sequence.
         i.e.  endElement[i] contains the end element of increasing sequence of length i+1
      */
        map = new int[size];
      int[] endElement = new int[size];
      int lisLen = 0;

      endElement[0] = arr[0];
      lisLen = 1;
      map[0] = lisLen;

      for(int i = 1; i < size; i++) {
          if(arr[i]<endElement[0]) {
             endElement[0] = arr[i];
              map[i] = 1;
          }

          else if(arr[i]>=endElement[lisLen-1]) {
             endElement[lisLen++] = arr[i];
              map[i] = lisLen;
          }

          else {
            int index = binarySearch(endElement,-1,lisLen-1,arr[i]);
            endElement[index] = arr[i];
              map[i] = index+1;
          }
      }

      return lisLen;
      
    }

    int binarySearch(int[] arr, int l, int r, int key) {
        int mid = l+(r-l)/2;
        while(l+1<r) {
           if(arr[mid]>key) r = mid;
           else l = mid;
           mid = l+(r-l)/2;
        }

        return r;
    }
}