class Solution {
    public int[] longestObstacleCourseAtEachPosition(int[] obs) {
        int n = obs.length;
        int[] tail = new int[n];//tail[i]含义是obs中所有所有长度为i + 1的严格上升子序列中序列结尾的最小值
        int[] ans = new int[n];
        
        tail[0] = obs[0];
        int end = 0;//指向tail数组最后一个有值的位置
        ans[0] = 1;
        
        for(int i = 1; i < n; i++) {
            if(obs[i] >= tail[end]) {
                end++;
                tail[end] = obs[i];
                ans[i] = end + 1;
            } else {
                int left = 0;
                int right = end;
                while(left < right) {
                    int mid = left + (right - left) / 2;
                    if(tail[mid] < obs[i] + 1) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                tail[left] = obs[i];
                ans[i] = left + 1;
            }
            
        }
        
        return ans;
        
    }
}