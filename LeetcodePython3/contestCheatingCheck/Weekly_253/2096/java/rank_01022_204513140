class Solution
{
    static class BinaryIndexTree
    {
        int[] tree;
        int len;

        BinaryIndexTree(int n)
        {
            len=n;
            tree=new int[n];
        }

        private int LowBit(int x)
        {
            return x&(-x);
        }

        public void update(int x, int k)
        {
            while(x<len)
            {
                tree[x]=Math.max(tree[x], k);
                x+=LowBit(x);
            }
        }

        public int query(int x)
        {
            int sum=0;
            while(x>0)
            {
                sum=Math.max(tree[x], sum);
                x-=LowBit(x);
            }
            return sum;
        }
    }

    public int[] longestObstacleCourseAtEachPosition(int[] nums)
    {
        TreeSet<Integer> set=new TreeSet<>();
        for(int num : nums)
            set.add(num);

        //给每一个不同的元素按照升序分配从1开始的索引
        Map<Integer, Integer> map=new HashMap<>();
        int idx=1;
        for(int num : set)
            map.put(num, idx++);

        //此时的最小值为1， 最大值max(去重后元素的数量)
        int max=idx;

        //树状数组
        BinaryIndexTree bit=new BinaryIndexTree(max+1);

        int[] ans=new int[nums.length];
        //逆序遍历
        for(int i=0; i<nums.length; i++)
        {
            //查询小于当前元素出现的次数，使用分配的索引而不是原始值
            ans[i]=bit.query(map.get(nums[i]))+1;

            bit.update(map.get(nums[i]), ans[i]);
        }

        return ans;
    }
}