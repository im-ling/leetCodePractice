class Solution {
    public int[] longestObstacleCourseAtEachPosition(int[] obstacles) {
        int[] ans = new int[obstacles.length];
        int n = obstacles.length;
        int[] mem = new int[n + 1]; // mem[i] 代表递增子序列长度为i时的最小a值
        mem[0] = Integer.MIN_VALUE;
        mem[1] = obstacles[0];

        ans[0] = 1;
        int l = 0, r = 1;
        for (int i = 1; i < n; i++) {
            int curNum = obstacles[i];
            int lastLessIdx = floorIdx(mem, l, r, curNum);
            int curLength = lastLessIdx + 1;
            mem[curLength] = curNum;
            r = Math.max(r, curLength);
            ans[i] = curLength;
        }
        return ans;
    }

    private int floorIdx(int[] arr, int l, int r, int target) {
        while (l <= r) {
            int mid = (l + r) >> 1;
            int midNum = arr[mid];
            if (midNum <= target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return r;
    }
}