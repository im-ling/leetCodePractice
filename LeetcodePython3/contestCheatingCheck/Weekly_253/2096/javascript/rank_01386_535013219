/**
 * @param {number[]} obstacles
 * @return {number[]}
 */
var longestObstacleCourseAtEachPosition = function (A) {
  // const n = A.length;
  // const dp = Array(n).fill(1); // dp[i] means the LIS ending with i
  // let res = 1;
  // for (let i = 1; i < n; i++) {
  //   let cur = 1;
  //   for (let j = 0; j < i; j++)
  //     if (A[i] >= A[j]) cur = Math.max(cur, dp[j] + 1);
  //   dp[i] = cur;
  //   // res = Math.max(res, cur);
  //   // dp[i] = Math.max(
  //   //   1,
  //   //   A[i] > A[i - 1] && (dp[i - 1] + 1),
  //   //   ...
  //   // );
  // }
  // return dp;

  const piles = [A[0]];
  const res = [1];
  for (let i = 1; i < A.length; i++) {
    // Find the first piles[m] >= A[i]
    let [l, r] = [0, piles.length - 1];
    while (l < r) {
      const m = (l + r) >> 1;

      if (piles[m] <= A[i]) l = m + 1;
      else r = m; // It's valid, should include m
    }

    if (piles[l] <= A[i]) l++;
    piles[l] = A[i];

    res.push(l + 1);
  }
  return res;
};