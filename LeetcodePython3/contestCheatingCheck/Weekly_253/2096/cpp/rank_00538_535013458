class Solution {
public:
    template<typename T>
    struct segtree{
        vector<T>tr;
        int def;

        void init(int N,int x){
            tr.assign(4*N+10,x);
            def=x;
        }
        T merge(T x,T y){
            return max(x,y);
        }
        void build(int no,int l,int r,vector<T>&v){
            if(l==r){
                tr[no]=v[l];
                return;
            }
            int mid=(l+r)>>1;
            build(no<<1,l,mid,v);
            build(no<<1|1,mid+1,r,v);
            tr[no]=merge(tr[no<<1],tr[no<<1|1]);
        }
        void update(int no,int l,int r,int wh,T x){
            if(l==r){
                tr[no]=x;
                return;
            }
            int mid=(l+r)>>1;
            if(wh<=mid) update(no<<1,l,mid,wh,x);
            else update(no<<1|1,mid+1,r,wh,x);
            tr[no]=merge(tr[no<<1],tr[no<<1|1]);
        }
        T qry(int no,int l,int r,int st,int en){
            if(r<st||l>en) return def;
            if(l>=st&&r<=en) return tr[no];
            int mid=(l+r)>>1;
            return merge(qry(no<<1,l,mid,st,en),qry(no<<1|1,mid+1,r,st,en));
        }
    };

    vector<int> longestObstacleCourseAtEachPosition(vector<int>& a) {
        set<int>s;
        for(auto x:a) s.insert(x);
        map<int,int>mp;
        int idx=0;
        for(auto x:s){
            mp.insert({x,idx++});
        }
        for(auto &x:a){
            x=mp[x];
        }
        segtree<int>sg;
        sg.init(idx,0);
        vector<int>ans;
        for(auto x:a){
            int val=1+sg.qry(1,0,idx-1,0,x);
            ans.push_back(val);
            sg.update(1,0,idx-1,x,val);
        }
        return ans;
    }
};