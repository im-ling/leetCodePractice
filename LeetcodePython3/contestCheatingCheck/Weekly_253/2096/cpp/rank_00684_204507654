const int MAXN = 4e5 + 6;

struct TreeNodes {
    int l, r, m;
} tree[MAXN];

void build(int x, int l, int r) {
    tree[x].l = l;
    tree[x].r = r;
    tree[x].m = 0;
    if (l == r) {
        return;
    }
    int mid = (l + r) / 2;
    build(x * 2, l, mid);
    build(x * 2 + 1, mid + 1, r);
}

void update(int x, int pos, int v) {
    tree[x].m = max(tree[x].m, v);
    if (tree[x].l == tree[x].r) {
        return;
    }
    int mid = (tree[x].l + tree[x].r) / 2;
    if (pos <= mid) {
        update(x * 2, pos, v);
    } else {
        update(x * 2 + 1, pos, v);
    }
}

int query(int x, int l, int r) {
    if (tree[x].l == l && tree[x].r == r) {
        return tree[x].m;
    }
    int mid = (tree[x].l + tree[x].r) / 2;
    if (r <= mid) {
        return query(x * 2, l, r);
    }
    if (l > mid) {
        return query(x * 2 + 1, l, r);
    }
    return max(query(x * 2, l, mid), query(x * 2 + 1, mid + 1, r));
}


class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        int n = static_cast<int>(obstacles.size());
        vector<pair<int, int>> p(n);
        for (int i = 0; i < n; ++i) {
            p[i] = {obstacles[i], i};
        }
        sort(p.begin(), p.end());
        vector<int> results(n);
        build(1, 0, n - 1);
        for (int i = 0; i < n; ++i) {
            int pos = p[i].second;
            results[pos] = query(1, 0, pos) + 1;
            update(1, pos, results[pos]);
        }
        return results;
    }
};