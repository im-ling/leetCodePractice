class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {
        int n = nums.size() ;
        vector<int> res(n) ; 
        vector<int> f(n+1 , 1e8) ;  // 维护f[i] 长度为i最长上升子序列 最后一个数字的最小值
        
        for (int i = 1 ; i <= n ; i++){
            int l = 0 , r = n ;
            while( l < r) {
                int mid = (l + r +1 ) >>1 ; 
                if(f[mid] <= nums[i-1]) l = mid  ; 
                else r = mid-1 ;
            }//找到最大的 比它小的数
            res[i-1] = l+1 ;
            f[l+1] = min(f[l+1 ] , nums[i-1]) ;
        }
        return res ; 
    }
};