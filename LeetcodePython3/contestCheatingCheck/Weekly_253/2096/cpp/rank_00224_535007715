const int N = 2e5;
int seg[4 * N];
class Solution {
public:
    void update(int v, int tl, int tr, int pos, int val) {
        if (tl == tr) {
            seg[v] = max(seg[v], val);
            return;
        }
        int mid = (tl + tr) / 2;
        if (pos <= mid) update(2 * v, tl, mid, pos, val);
        else    update(2 * v + 1, mid + 1, tr, pos, val);
        seg[v] = max(seg[2 * v], seg[2 * v + 1]);
    }
    
    int query(int v, int tl, int tr, int l, int r) {
        if (l > r)  return 0;
        // cout << v << " " << tl << " " << tr << " " << l << " " << r << endl;
        if (tl == l && tr == r) {
            return seg[v];
        }
        int mid = (tl + tr) / 2;
        return max(query(2 * v, tl, mid, l, min(r, mid)),    query(2 * v + 1, mid + 1, tr, max(l, mid + 1), r));
    }
    
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& a) {
        int n = a.size();
        for (int i = 0; i <= 4 * n; i++)    seg[i] = 0;
        
        vector<pair<int, int>> v;
        for (int i = 0; i < n; i++) {
            v.push_back({a[i], i});
        }
        sort(v.begin(), v.end());
        vector<int> b(n);
        int cur = -1, prev = -1;
        for (auto x : v) {
            if (x.first != prev) {
                cur++;
            }
            b[x.second] = cur;
            prev = x.first;
        }
        // for (auto x : b) {
        //     cout << x << " ";
        // }
        // cout << endl;
        
        map<int, int> maxi;
        
        vector<int> ans;
        for (int i = 0; i < n; i++) {
            int p = query(1, 0, n - 1, 0, b[i]);
            ans.push_back(p + 1);
            if (maxi.count(b[i]) == 0 || maxi[b[i]] < p + 1);
            update(1, 0, n - 1, b[i], p + 1);
        }
        
        return ans;
        
    }
};