class Solution {
public:
    int node[(int)4e5 + 1000];
    void build(int o,int l,int r) {
        if(l == r) {
            node[o] = 0;
            return;
        }
        
        int mid = (l + r) / 2;
        build(o * 2, l, mid);
        build(o * 2 + 1, mid + 1, r);
        node[o] = max(node[o * 2], node[o * 2]);
    }
    
    int query(int o,int l,int r,int L,int R) {
        if(L <= l && r <= R) {
            return node[o];
        }
        
        int mid = (l + r) / 2;
        if(R <= mid) {
            return query(o * 2, l, mid, L, R);
        }
        else if(mid + 1 <= L) {
            return query(o * 2 + 1, mid + 1, r, L, R);
        }
        else {
            int ans1 = query(o * 2, l, mid, L, mid);
            int ans2 = query(o * 2 + 1, mid + 1, r, mid + 1, R);
            return max(ans1, ans2);
        }
    }
    
    void insert(int o,int l,int r,int ix, int val) {
        if(l == r && l == ix) {
            node[o] = val;
            return;
        }
        
        int mid = (l + r) / 2;
        if(ix <= mid) {
            insert(o * 2,l, mid, ix, val);
        }
        else {
            insert(o * 2 + 1, mid + 1, r, ix, val);
        }
        
        node[o] = max(node[o * 2], node[o * 2 + 1]);
    }
    
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        vector<int> discret;
        for(int i = 0; i < obstacles.size();i ++) {
            discret.push_back(obstacles[i]);
        }
        sort(discret.begin(), discret.end());
        
        map<int,int> hash;
        for(int i = 0;i < discret.size();i ++) {
            if(hash[discret[i]] == 0) {
                hash[discret[i]] = i + 1;
            }
        }
        
        for(int i = 0; i < obstacles.size();i ++) {
            obstacles[i] = hash[obstacles[i]];
        }
        
        int n = obstacles.size();
        build(1, 1, n);
        
        vector<int> res;
        
        for(int i = 0;i < n;i ++) {
            int now = obstacles[i];
            int ans = query(1, 1, n, 1, now);
            res.push_back(ans + 1);
            insert(1, 1, n, now, ans + 1);
        }
        return res;
    }
};