class Solution {
    const int inf = 1e9;
    class SegTree{
        vector<int> t;
        public:

        SegTree(int n){
            t.resize(n * 4 , 0);
        }

        void update(int v , int tl , int tr , int pos , int ele){
            if(tl == tr){
                t[v] = max(t[v] , ele);
            }
            else{
                int tm = (tl + tr) >> 1;
                if(pos <= tm){
                    update(2*v , tl , tm , pos , ele);
                }
                else update(2*v+1 , tm+1 , tr , pos , ele);
                t[v] = max(t[2*v] , t[2*v+1]);
            }
        }

        int query(int v , int tl , int tr , int l , int r){
            if(l > r)return 0;
            if(l == tl && r == tr){
                return t[v];
            }
            int tm = (tl + tr) >> 1;
            return max(query(2*v , tl , tm , l , min(r , tm)) , query(2*v+1 , tm+1 , tr , max(l , tm+1) , r));
        }
    };
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& a) {
        int n = a.size();
        
        vector<int> b = a;
        sort(b.begin() , b.end());
        int cnt = 0;
        
        map<int , int> m;
        for(int i = 0 ; i < n ; i++) {
            if(i == 0 || b[i] != b[i-1]) {
                m[b[i]] = cnt++;
            }
        }
        
        for(int i = 0 ; i < n ; i++) {
            a[i] = m[a[i]];
        }
        
        vector<int> ans(n);
        SegTree s(cnt+1);
        for(int i = 0 ; i < n ; i++) {
            ans[i] = s.query(1 , 0 , cnt-1 , 0 , a[i]) + 1;
            s.update(1 , 0 , cnt-1 , a[i] , ans[i]);
        }
        
        return ans;
    }
};