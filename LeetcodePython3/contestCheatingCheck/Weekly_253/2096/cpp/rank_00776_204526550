class Solution {
public:  
    static const int maxn = 100007;
    const int inf = 0x7f7f7f7f;
    int n, m;
    int tree[4*maxn];
    int arr[maxn];
    
    void build_tree(int node, int left, int right) {//ind:index in array tree[]
        if (left == right) {
            tree[node] = arr[left];
        } else {
            int mid = (left + right) >> 1;
            int left_node = 2*node + 1, right_node = 2*node + 2;
            build_tree(left_node, left, mid);
            build_tree(right_node, mid + 1, right);
            tree[node] = max(tree[left_node], tree[right_node]);
        }
    }
    
    void update_tree(int node, int left, int right, int idx, int val) {//node:index in array tree[], idx:index in array arr[]
        if (left == right) {
            arr[idx] = val;
            tree[node] = val;
        } else if (idx < left || idx > right) {
            return;
        } else {
            int mid = (left + right) >> 1;
            int left_node = 2*node + 1, right_node = 2*node + 2;
            if (idx >= left && idx <= mid) {
                update_tree(left_node, left, mid, idx, val);
            } else {
                update_tree(right_node, mid + 1, right, idx, val);
            }
            tree[node] = max(tree[left_node], tree[right_node]);
        }
    }
    
    int query_tree(int node, int left, int right, int from, int to) {//query the max value from 'from' to 'to'
        if (to < left || from > right) {
            return -inf;
        } else if (from <= left && right <= to) {
            return tree[node];
        } else {
            int mid = (left + right) >> 1;
            int left_node = 2*node + 1, right_node = 2*node + 2;
            return max(query_tree(left_node, left, mid, from, to), query_tree(right_node, mid + 1, right, from, to));
        }
    }
    
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        vector<int> arr = obstacles;
        arr.erase(unique(arr.begin(), arr.end()), arr.end());
        sort(arr.begin(), arr.end());
        
        int n = arr.size();
        build_tree(0, 0, n - 1);
        
        vector<int> ans;
        for(auto ob : obstacles){
            ob = lower_bound(arr.begin(), arr.end(), ob) - arr.begin();
            int tmp = query_tree(0, 0, n - 1, 0, ob) + 1;
            ans.push_back(tmp);
            update_tree(0, 0, n - 1, ob, tmp);
        }
        return ans;
    }
};