template<typename T> class Compress{
	//Compress<int> ca({5,1,2,3});
	//ca.id(5) //=3
private:
	vector<T> vec;
	vector<int> id_perm;//v1 index -> vec index
public:
	void init(const vector<T>& v1){
		int n=v1.size();
		int i,j;
		id_perm.assign(n,-1);
		vector<pair<T,int>> va;
		for(i=0;i<n;i++){
			va.push_back({v1[i],i});
		}
		sort(va.begin(),va.end());
		vec.clear();
		for(i=0,j=-1;i<n;i++){
			if(vec.empty() || vec.back()!=va.back().first){
				vec.push_back(va[i].first);
				j++;
			}
			id_perm[va[i].second]=j;
		}
	}

	Compress(const vector<T> v1){
		init(v1);
	}

	vector<int> get_id_perm()const{
		return id_perm;
	}

	int id(const T a){
		auto itr=lower_bound(vec.begin(),vec.end(),a);
		assert(itr!=vec.end());//return -1?
		assert(*itr==a);
		return itr-vec.begin();
	}
};

template <typename T> class seg_tree{
	//monoid
private:
	function<T(T,T)> func;
	T e;
	int N,n=-1;
	vector<T> seg;

	void init(){
		assert(n>=0);
		int i;
		for(i=0;(1<<i)<n;i++);
		N=(1<<i)-1;
		seg.assign(2*(N+1),e);
	}

	void init_reload(){
		for(int i=N-1;i>=0;i--){
			seg[i]=func(seg[2*i+1],seg[2*i+2]);
		}
	}
	
	void update(int pos){
		T a=func(seg[pos*2+1],seg[pos*2+2]);
		if(seg[pos]==a)return;
		seg[pos]=a;
		if(pos==0)return;
		update((pos-1)/2);
	}

public:
	seg_tree(function<T(T,T)> _func,T _e,int _n):func(_func),e(_e),n(_n){
		init();
	}
	seg_tree(function<T(T,T)> _func,T _e,vector<T> vec):func(_func),e(_e){
		n=vec.size();
		init();
		for(int i=0;i<n;i++){
			seg[N+i]=vec[i];
		}
		init_reload();
	}
	seg_tree(function<T(T,T)> _func,T _e,int _n,T a):func(_func),e(_e),n(_n){
		init(e);
		for(int i=0;i<n;i++){
			seg[N+i]=a;
		}
		init_reload();
	}

	void set(int pos,T a){
		assert(pos>=0 && pos<=N);
		pos+=N;
		seg[pos]=a;
		update((pos-1)/2);
	}

	T search(int a,int b,int l,int r,int x){//[a,b) search
		if(a<=l && r<=b)return seg[x];
		int m=(l+r)/2;
		if(b<=m)return search(a,b,l,m,2*x+1);
		if(m<=a)return search(a,b,m,r,2*x+2);
		return func(search(a,m,l,m,2*x+1),search(m,b,m,r,2*x+2));
	}
	T search(int a,int b){
		assert(a<b);
		return search(a,b,0,N+1,0);
	}

	int max_right(function<bool(T)>& g,int pos,int l,int r,int x,T& y){
		//suppose that S is return value, g(func(pos,..,S-1))=true,g(func(pos,..,S))=false
		if(pos<=l && g(func(y,seg[x]))){
			y=func(y,seg[x]);
			return r;
		}
		if(l+1==r)return l;
		int m=(l+r)/2;
		if(pos<m){
			int s=max_right(g,pos,l,m,2*x+1,y);
			if(s<m)return s;
		}
		return max_right(g,pos,m,r,2*x+2,y);
	}
	int max_right(function<bool(T)> g,int pos){
		T y=e;
		int s=max_right(g,pos,0,N+1,0,y);
		return min(s,n);
	}

	int min_left(function<bool(T)>& g,int pos,int l,int r,int x,T& y){
		//suppose that S is return value, g(func(S,..,pos-1))=true,g(func(S-1,..,pos-1))=false
		int s;
		if(r<=pos && g(func(seg[x],y))){
			y=func(seg[x],y);
			return l;
		}
		if(l+1==r)return r;
		int m=(l+r)/2;
		if(m<pos){
			s=min_left(g,pos,m,r,2*x+2,y);
			if(m<s)return s;
		}
		return min_left(g,pos,l,m,2*x+1,y);
	}
	int min_left(function<bool(T)> g,int pos){
		assert(pos>=0);
		if(pos==0)return 0;
		T y=e;
		return min_left(g,pos,0,N+1,0,y);
	}
};

class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        Compress<int> ca(obstacles);
		int n=obstacles.size();
		int i,j,k;
		int a,b;
		seg_tree<int> seg([](int a,int b){return max(a,b);},0,n);
		vector<int> vs;
		for(i=0;i<n;i++){
			a=ca.id(obstacles[i]);
			b=seg.search(0,a+1);
			seg.set(a,b+1);
			vs.push_back(b+1);
		}
		return vs;
    }
};